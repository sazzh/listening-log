-- Schemas used for the PostgreSQL database
-- includes information about specific design decisions

-- GENERATED BY DEFAULT AS IDENTITY is used for auto-incrementing primary keys
-- chosen over serial as outdated
-- by default instead of always to allow manual insertion of Ids

-- TIMESTAMPTZ is used for created_at and updated_at to store timezone-aware timestamps

CREATE TABLE IF NOT EXISTS Artists (
	artist_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	artist_name TEXT NOT NULL,
	artist_type TEXT NOT NULL,
	artist_country TEXT NOT NULL,
	artist_disambiguation TEXT, -- additional info to distinguish artists with similar names
	is_disbanded BOOL DEFAULT FALSE,
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
)

CREATE TABLE IF NOT EXISTS Albums (
	album_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	album_name TEXT NOT NULL,
	num_of_songs SMALLINT NOT NULL CHECK (num_of_songs >= 0),
	date_released DATE NOT NULL,
	album_type TEXT, -- e.g. album, ep, single
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	artist_id INTEGER REFERENCES artists(artist_id)
)

CREATE TABLE IF NOT EXISTS Songs (
	song_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	song_name TEXT NOT NULL,
	song_length INTEGER,
	date_released DATE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
)

-- Associative table to allow songs to have multiple artists
CREATE TABLE IF NOT EXISTS Song_Artists (
	song_id INTEGER NOT NULL REFERENCES songs(song_id) ON DELETE CASCADE,
	artist_id INTEGER NOT NULL REFERENCES artists(artist_id) ON DELETE CASCADE, -- deletes association if either song/artist are deleted
	PRIMARY KEY (song_id, artist_id)	
)

-- Associative table to allow songs to be on multiple albums
CREATE TABLE IF NOT EXISTS Song_Albums (
	song_id INTEGER NOT NULL REFERENCES songs(song_id) ON DELETE CASCADE,
	album_id INTEGER NOT NULL REFERENCES albums(album_id) ON DELETE CASCADE,
	track_number INTEGER -- specfic to each album
	PRIMARY KEY (song_id, album_id)
)

-- Enable case-insensitive text extension
CREATE EXTENSION citext;

CREATE TABLE IF NOT EXISTS Users (
	user_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	username TEXT UNIQUE NOT NULL,
	passwd TEXT NOT NULL,
	first_name TEXT NOT NULL,
	last_name TEXT,
	email CITEXT, -- case-insensitive email (to prevent duplication)
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
)

CREATE TABLE IF NOT EXISTS Roles (
	role_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	role_name TEXT NOT NULL
)

-- Associative table to allow users to have multiple roles
CREATE TABLE IF NOT EXISTS user_roles (
	user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
	role_id INTEGER NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
	PRIMARY KEY (user_id, role_id)
)

CREATE TABLE IF NOT EXISTS Playlists (
	playlist_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	playlist_name TEXT NOT NULL,
    playlist_description TEXT,
    user_id INTEGER NOT NULL REFERENCES users(user_id),
	created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
)

-- Associative table to allow songs to be in multiple playlists
CREATE TABLE IF NOT EXISTS song_playlists (
	song_id INTEGER NOT NULL REFERENCES songs(song_id) ON DELETE CASCADE,
	playlist_id INTEGER NOT NULL REFERENCES playlists(playlist_id) ON DELETE CASCADE,
	PRIMARY KEY (song_id, playlist_id)
)

-- Log all user update activity so history can be tracked/displayed
CREATE TABLE IF NOT EXISTS UserEvents (
	event_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	user_id INTEGER NOT NULL REFERENCES users(user_id),
	entity_type TEXT NOT NULL, -- song, artist, playlist, album
	entity_id INTEGER NOT NULL, -- id of entity e.g. song_id
	event_type TEXT NOT NULL, -- listened, added/removed playlist, added note etc.
	event_data JSONB, -- optional metadata e.g. playlist_id song was added to
	created_at TIMESTAMPTZ NOT NULL DEFAULT now()
	-- no updated_at as read-only after creation
)

-- Create trigger to update 'updated_at' timestamp on record modification
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
	NEW.updated_at = now();
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to all tables with updated_at field
CREATE TRIGGER artists_set_updated_at
BEFORE UPDATE ON artists
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER albums_set_updated_at
BEFORE UPDATE ON albums
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER songs_set_updated_at
BEFORE UPDATE ON songs
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

--  TO DO: add trigger to userartistprefs, artistnotes, users, artistnotes, usersongprefs, playlists tablesCREATE TRIGGER users_set_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER playlists_set_updated_at
BEFORE UPDATE ON playlists
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER user_song_preferences_set_updated_at
BEFORE UPDATE ON user_song_preferences
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER user_artist_preferences_set_updated_at
BEFORE UPDATE ON user_artist_preferences
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

--  TO DO: add trigger to artistnotes, artistnotes tables